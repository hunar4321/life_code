<html>

  <head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
      :root {
        color-scheme: dark;
      }

      body {
        display: flex;
        /*justify-content: center;*/
        /*align-items: center;*/
        position: relative;
      }

      #canvas {
        border: #504e52;
        border-style: dashed;
        border-width: 5;
      }

      .tablink {
        background-color: #555;
        color: white;
        float: left;
        border: none;
        outline: none;
        cursor: pointer;
        padding: 14px 16px;
        font-size: 17px;
        width: 20%;
      }
      .tablink:hover { background-color: #777; }

      #controls {
        color: black;
        padding: 10px;
        /*text-align: center;*/
        background-color: #eaeaea;
        position:absolute;
        bottom:0;
        right:0;
        width:50%;
      }
      #tab_box {
        position: absolute;
        bottom:0;
        width:40%;
      }
      .slider {
        width: 50%;
      }
      .cbox {
        text-align:center;
        color: black;
        border: 2px solid black;
      }
    </style>
  </head>

  <body>
    <div id='tab_box'></div>
    <div id='controls'>
      Interaction strength:</br>
      <div id='sliders1'></div><br/>
      <div id='sliders2'>Radius:
        <input class='slider' type="range" value="80" id="cR" min="1" max="100" oninput="changeSlider(this)">
        <output></output><br>
      </div>
    </div>

    <p><div><canvas id="canvas"></canvas></div></p>

    <script>   // governing parameters
      var seed = 91651088029;
      const Colors = ['green', 'red', 'orange', 'blue'];   // four particle types
      // const Colors = ['green', 'red', 'yellow'];
      // const Colors = ['green', 'red'];
      let time_scale = 1.0;
      const viscosity = 0.7;   // speed-dampening
      const pulseDuration = 10;
      const RULES = {};
      const RADIUS = {};
    </script>

    <script>
      var reload_rules = false;
      let changeSlider = (elmnt) => {
        var v = elmnt.valueAsNumber;
        elmnt.nextElementSibling.value = TwoDigits(v);
        reload_rules = true;
      };
      var sl = document.getElementById("sliders1");
      var tb = document.getElementById("tab_box");
      var sl_html = "";
      var tb_html = "";
      sl_html += "<table class='cbox'>";
      for (var c in Colors) {
        sl_html += "<tr><td style='width:20%;background-color:" + Colors[c] + ";'>" + Colors[c] + "</td>";
        sl_html += "<td style='width:80%;'><input type='range' value='0' id='slider" + c + "' ";
        sl_html += "min='-1' max='1' step='any' oninput='changeSlider(this)'>";
        sl_html += "<output></output></td></tr>";

        tb_html += "<button id='button" + c + "' ";
        tb_html += "class='tablink' onclick='openControl(" + c + ")'>" + Colors[c] + "</button>";
      }
      sl_html += "</table>";

      sl.innerHTML = sl_html;
      tb.innerHTML = tb_html;

      var last_group_id = 0;
      function openControl(group_id) {
        if (group_id < 0) group_id = last_group_id;
        last_group_id = group_id;
        var elmnt = document.getElementById("button" + group_id);
        var color = Colors[group_id];
        var t = document.getElementById("controls");
        t.style.display = "block";

        // Remove the background color of all tablinks/buttons
        for (var t of document.getElementsByClassName("tablink")) {
          t.style.backgroundColor = "";
          t.style.border = "";
        }

        // Add the specific color to the button used to open the tab content
        elmnt.style.backgroundColor = color;
        elmnt.style.border = '1px solid gray';

        if (RULES[color] != undefined) {
          for (var c in Colors) {
            let s = document.getElementById("slider" + c);
            s.valueAsNumber = RULES[color][Colors[c]];
            s.oninput.apply(s);  // triggers refresh
          }
        }
        if (RADIUS[color] != undefined) {
          let s = document.getElementById("cR");
          s.valueAsNumber = RADIUS[color];
          s.oninput.apply(s);
        }
      }
      function reloadRules() {
        const color = Colors[last_group_id];
        for (var c in Colors) {
          let s = document.getElementById("slider" + c);
          RULES[color][Colors[c]] = s.valueAsNumber;
        }
        RADIUS[color] = document.getElementById("cR").valueAsNumber;
      }
    </script>

    <script>
    // Seedable 'decent' random generator
    function mulberry32() {
      var t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296.;
    }
    var hash = window.location.hash;
    if (hash != undefined && hash[0] == '#') {
      var param = Number(hash.substr(1));  // remove the leading '#'
      if (isFinite(param)) {
        seed = param;
        console.log("Using seed " + seed);
      }
    }

    </script>

    <script>
      // Rules values
      function randomRules() {
        if (!isFinite(seed)) seed = 0xcafecafe;
        console.log("Seed=" + seed);
        window.location.hash = "#" + seed;
        for (var i of Colors) {
          RULES[i] = {};
          for (var j of Colors) {
            RULES[i][j] = mulberry32() * 2 - 1;
          }
          RADIUS[i] = 80;       // interaction distance cut-off
        }
        console.log(JSON.stringify(RULES));
        console.log(JSON.stringify(RADIUS));
        time_scale = 1.;
        openControl(-1);
      }
      function symmetricRules() {
        for (var i of Colors) {
          for (var j of Colors) {
            if (j < i) {
              let v = 0.5 * (RULES[i][j] + RULES[j][i]);
              RULES[i][j] = RULES[j][i] = v;
            }
          }
        }
        console.log(JSON.stringify(RULES));
        console.log(JSON.stringify(RADIUS));
        openControl(-1);
      }
      function printRules() {
        for (var i of Colors) {
          let str = "";
          for (var j of Colors) str += TwoDigits(RULES[i][j]) + " ";
          str += " RADIUS: " + RADIUS[i];
          console.log(str);
        }
      }
    </script>


    <script>
      // Canvas
      const canvas = document.getElementById('canvas');
      
      updateCanvasDimensions()
      function updateCanvasDimensions() {
        canvas.width = window.innerWidth * 0.95;
        canvas.height = window.innerHeight * 0.8;
      }

      const m = canvas.getContext("2d");
      const draw = (x, y, c, s) => {
        m.fillStyle = c;
        m.fillRect(x, y, s, s);
      };

      // Atoms array
      const atoms = [];
      const atom = (x, y, c) => {
        return { x: x, y: y, vx: 0, vy: 0, color: c };
      };

      // Initiate Random locations for Atoms ( used when atoms created )
      function randomX() {
        return mulberry32() * (canvas.width - 100) + 50;
      };
      function randomY() {
        return mulberry32() * (canvas.height - 100) + 50;
      };

      // Create an Atoms
      const create = (number, color) => {
        for (let i = 0; i < number; i++) {
          atoms.push(atom(randomX(), randomY(), color));
        }
      };

      function randomAtoms(number_of_atoms_per_color, clear_previous) {
        if (clear_previous) atoms.length = 0;
        for (var c of Colors) create(number_of_atoms_per_color, c);
      }

      // Apply Rules ( How atoms interact with each other )
      var pulse = 0;
      var pulse_x = 0, pulse_y = 0;
      var total_v;  // average speed, so that we can scale the time_scale value
      const applyRules = () => {
        total_v = 0.;
        // Update speed vx/vy first
        for (let a of atoms) {
          let fx = 0;
          let fy = 0;
          const r2 = RADIUS[a.color] * RADIUS[a.color];
          for (let b of atoms) {
            const g = RULES[a.color][b.color];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const d = dx * dx + dy * dy;
            if (d > 0 && d < r2) {
              const F = g / Math.sqrt(d);
              fx += F * dx;
              fy += F * dy;
            }
          }
          if (pulse != 0) {
            const dx = a.x - pulse_x;
            const dy = a.y - pulse_y;
            const d = dx * dx + dy * dy;
            if (d > 0) {
              const F = 100. * pulse / (d * time_scale);
              fx += F * dx;
              fy += F * dy;
            }
          }
          const vmix = (1. - viscosity);
          a.vx = a.vx * vmix + fx * time_scale;
          a.vy = a.vy * vmix + fy * time_scale;
          total_v += Math.abs(a.vx);
          total_v += Math.abs(a.vy);
        }
        // update positions
        for (let a of atoms) {
          a.x += a.vx;
          a.y += a.vy;
          
          // When Atoms touch or bypass canvas borders
          // X - axis
          if (a.x < 0 || a.x >= canvas.width) {
            a.vx *= -1;
            a.x = (a.x < 0) ? 0 : canvas.width - 1;
          }
          // Y - axis
          if (a.y < 0 || a.y >= canvas.height) {
            a.vy *= -1;
            a.y = (a.y < 0) ? 0 : canvas.height - 1;
          }
        }
        total_v /= atoms.length;
      };


      randomRules();  // Generate rules

      randomAtoms(500, true);  // Create Atoms

      var show_fps = false;
      var lastT = Date.now();
      var fps = 0;
      window.addEventListener('keydown',
        (e) => { switch (e.code) {
                   case 'KeyF': show_fps = !show_fps; break;
                   case 'KeyR': randomRules(); break;
                   case 'KeyS': symmetricRules(); break;
                   case 'KeyP': randomAtoms(100, false); break;
                   case 'KeyO': randomAtoms(500, true); break;
                   case 'BracketRight': time_scale *= 1.1; break;
                   case 'BracketLeft': time_scale /= 1.1; break;
                   case 'KeyM': printRules(); break;
                   default: console.log(e.code);
                 }
               });
      canvas.addEventListener('click',
        (e) => { pulse = pulseDuration;
                 pulse_x = e.clientX;
                 pulse_y = e.clientY; }
      );

      // Update Frames
      update();
      function TwoDigits(x) { return Math.floor(100. * x) / 100.; }
      function update() {
        // Update Canvas Dimensions - if screen size changed
        updateCanvasDimensions()

        if (reload_rules) {  // slider changed
          reloadRules();
          reload_rules = false;
        }
        applyRules();
        m.clearRect(0, 0, canvas.width, canvas.height);
        for (i = 0; i < atoms.length; ++i) {
          draw(atoms[i].x, atoms[i].y, atoms[i].color, 3);
        }
        if (show_fps) {
          var curT = Date.now();
          if (curT > lastT) {
            const new_fps = 1000. / (curT - lastT);
            fps = fps * 0.8 + new_fps * 0.2;
            lastT = curT;
          }
          m.fillStyle ="white";
          m.font = '32px serif';
          m.fillText(TwoDigits(fps) + " FPS", 10, 36);
          m.fillText("dt: " + TwoDigits(time_scale) + " Atoms: " + atoms.length, 10, 96);
          m.fillText("total_v: " + TwoDigits(total_v), 10, 130);
        }
        seed = seed + 1;;
        if (pulse > 0) pulse -= 1;
        if (total_v > 30. && time_scale > 5.) time_scale /= 1.1;
        if (time_scale < 0.9) time_scale *= 1.01;
        if (time_scale > 1.1) time_scale /= 1.01;
        requestAnimationFrame(update);
      };

    </script>

  </body>

</html>
